#pragma config(Motor,  port2,           bodyRotateMotor, tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           armExtend,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           clawServo,     tmotorServoStandard, openLoop)
#pragma config(Motor,  port8,           clawSpin,      tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port9,           armMove,       tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int armMethod = 0;
int bound (int max1, int input1, int min1)
{
	// our input is too high
	if (input1 > max1)
	{
		return max1;

		// our input is too low
	}else if (input1 < min1)
	{
		return min1;

		//our input is within bounds
	}else
	{
		return input1;
	}
}

int parabolic(int readJoy, int gain, int maxval)
{
	int parabolicValue;

	//Algorithm:
	//parabolicValue = ((((gain * readJoy) / 100)^2)*(1/maxval));

	parabolicValue = ((gain * readJoy) / 100);
	parabolicValue = (parabolicValue * parabolicValue);
	parabolicValue = (parabolicValue/maxval);

	// Adjust the sign (if readJoy is a negative)
	if (readJoy < 0) {
		parabolicValue *=-1;
	}

	return(parabolicValue);
}


void rotateBody()
{
	int readJoy_x; // will hold the X value of the analog stick
	int joy_x; // will hold the X value after being applied to the parabolic scale
	int gain_x = 36; //change this when you change max/min Motor Speed
	int maxMotorSpeed = 40;
	int deadBand = 10;

	readJoy_x = vexRT[Ch4]; // This is the LEFT analog stick. For RIGHT, change 'Ch4' to 'Ch1'.
	joy_x=parabolic(readJoy_x, gain_x, maxMotorSpeed);
	/*if(readJoy_x <deadBand && readJoy_x > -deadBand){
	joy_x = 0;
	}else if (readJoy_x >= deadBand){
	joy_x = (readJoy_x*127/maxMotorSpeed-deadBand);
	}else if (readJoy_x <= -deadBand){
	joy_x = (readJoy_x*127/maxMotorSpeed+deadBand);
	}*/
	//joy_x = parabolic(readJoy_x, gain_x, maxMotorSpeed)
	int motorVal = bound(maxMotorSpeed, (joy_x), (-1 * maxMotorSpeed));		//this is an int for easy debugging
	motor[bodyRotateMotor] = motorVal;
}

void armVertical()
{
	int upButton;
	int downButton;
	int maxMotorSpeed = 127;
	/*Method 1: Front left buttons*/
	if (armMethod == 0){

		upButton = vexRT[Btn5U];
		downButton = vexRT[Btn5D];

		if (upButton == 1 && downButton == 1) {
			motor [armMove] = 0;
		}
		else if (upButton == 1) {
			downButton = 0;
			motor [armMove] = 127;
		}
		else if (downButton == 1) {
			upButton = 0;
			motor [armMove] = -127;
		}
		else if (upButton == 0 && downButton == 0){
			motor [armMove] = 0;
		}
	}
	/*Method 2: Left Joystick Y-axis*/
	else {
		int joy_y = vexRT[Ch3];
		int motorVal = bound(maxMotorSpeed, (joy_y), (-1 * maxMotorSpeed));		//this is an int for easy debugging
		motor[armMove] = motorVal;
	}

	/*Switch modes so drivers can try different methods during test drive.*/
	if (vexRT [Btn8D] == 1){
		armMethod = 0;
	}
	else if (vexRT [Btn8R] == 1) {
		armMethod = 1;
	}
}


void extendArm(){
	if(vexRT[Btn6U] == 1){
		motor[armExtend] = 127;
	}
	else if(vexRT[Btn6D] == 1){
		motor[armExtend] = -127;
	}
	else{
		motor[armExtend] = 0;
	}
}

void rotateClaw(){
	int joy_y;
	int maxMotorSpeed = 50;					//50 is allows it to spin with a heavy dowel
	joy_y = vexRT[Ch2];						//left joystick vertical
	joy_y = joy_y*maxMotorSpeed/127;		//adjust to scale to maxMotorSpeed
	int motorVal = bound(maxMotorSpeed, (joy_y), (-1 * maxMotorSpeed));			//bound isn't too necessary here, but why not
	motor[clawSpin] = motorVal;
}

void toggleClaw(){
	if (vexRT[Btn7L] == 1){
		motor[clawServo] = 0;		//open position
	}
	if(vexRT[Btn7D] == 1){
		motor[clawServo] = -127;	//close position
	}
}

/*An init function sets our servos and motors to their optimal starting settings*/
void init(){
	motor[clawServo] = -127;		//close the claw
}

task main ()
{
	init();
	while(true) // infinite loop, to keep the program alive
	{
		rotateBody();
		armVertical();
		extendArm();
		rotateClaw();
		toggleClaw();
	}
}