#pragma config(Motor,  port2,           bodyRotateMotor, tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           armExtend,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           clawServo,     tmotorServoStandard, openLoop)
#pragma config(Motor,  port8,           clawSpin,      tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port9,           armMove,       tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define RETRACTBUTTON vexRT[Btn6D]
#define EXTENDBUTTON vexRT[Btn6U]
#define CLAWOPENBUTTON vexRT[Btn8L]
#define CLAWCLOSEBUTTON vexRT[Btn8R]
#define SLOWMODEBUTTON vexRT[Btn8D]
#define armStick vexRT[Ch3]
#define bodyRotateStick vexRT[Ch4]
#define clawRotateStick vexRT[Ch2]

int slowMode = 0;
int bound (int max1, int input1, int min1)
{
	if (input1 > max1)			// our input is too high
	{
		return max1;
	}
	else if (input1 < min1)		// our input is too low
	{
		return min1;
	}
	else						//our input is within bounds
	{
		return input1;
	}
}

int parabolic(int readJoy, int gain, int maxval)
{
	int parabolicValue;

	/*
	 * Algorithm:
	 * parabolicValue = ((((gain * readJoy) / 100)^2)*(1/maxval));
	 */

	parabolicValue = ((gain * readJoy) / 100);
	parabolicValue = (parabolicValue * parabolicValue);
	parabolicValue = (parabolicValue/maxval);

	// Adjust the sign (if readJoy is a negative)
	if (readJoy < 0)
	{
		parabolicValue *=-1;
	}

	return(parabolicValue);
}


void rotateBody()
{
	int readJoy_x;			// will hold the X value of the analog stick
	int joy_x;				// will hold the X value after being applied to the parabolic scale
	int gain_x = 47;		//change this when you change max/min Motor Speed.  Graph in mathematica so it makes sense
	int maxMotorSpeed = 45;	//pretty slow
	int deadBand = 10;

	if(slowMode == 1)
	{
		gain_x = 24;
		maxMotorSpeed = 30;	//this just barely moves it, for those fine tuning
	}


	readJoy_x = vexRT[Ch4]; // This is the LEFT analog stick. For RIGHT, change 'Ch4' to 'Ch1'.
	//joy_x = parabolic(readJoy_x, gain_x, maxMotorSpeed);
	joy_x = joy_x*maxMotorSpeed/127;
	int motorVal = bound(maxMotorSpeed, (joy_x), (-1 * maxMotorSpeed));		//this is an int for easy debugging
	motor[bodyRotateMotor] = motorVal;
}

void armVertical()
{
	int maxMotorSpeed = 127;
	int joy_y = armStick;
	if(slowMode == 1){
		joy_y=joy_y*1/2;
		maxMotorSpeed = 64;
	}
	/*if(joy_y < 0)
	{
		joy_y=joy_y*1/2;		//Drivers want it to go slower down.  We already have gravity helping
	}*/
	int motorVal = bound(maxMotorSpeed, (joy_y), (-1 * maxMotorSpeed));
	motor[armMove] = motorVal;

}


void extendArm()
{
	int speed = 127;

	if(slowMode == 1)
	{
		speed = 90;
	}

	if(EXTENDBUTTON == 1)
	{
		motor[armExtend] = 127;
	}
	else if(RETRACTBUTTON == 1)
	{
		motor[armExtend] = -127;
	}
	else
	{
		motor[armExtend] = 0;
	}
}

void rotateClaw()
{
	int joy_y;
	int maxMotorSpeed = 97;

	if(slowMode == 1)
	{
		maxMotorSpeed = 50;					//50 just barely allows it to spin with a heavy dowel
		joy_y = joy_y*maxMotorSpeed/127;	//scale it down
	}

	joy_y = clawRotateStick;						//left joystick vertical
	joy_y = joy_y*maxMotorSpeed/127;
	int motorVal = bound(maxMotorSpeed, (joy_y), (-1 * maxMotorSpeed));
	motor[clawSpin] = motorVal;
}

void toggleClaw()
{
	if (CLAWOPENBUTTON == 1){
		motor[clawServo] = 0;		//open position
	}
	if(CLAWCLOSEBUTTON == 1){
		motor[clawServo] = -127;	//close position
	}
}

//drivers want a slow mode toggle button
int push=0;
/*void slowModeCheck()
{
	if(SLOWMODEBUTTON == 1 && push == 0)				//we don't want to toggle if if was pushed the last time we hit this function
	{
		push = 1;
		if(slowMode == 0)
		{
			slowMode = 1;
		}else
		{
			slowMode = 0;
		}
	}
	else
	{
		push = 0;
	}
}*/

/*An init function to make sure servos start in position, any other setup*/
void init(){
	motor[clawServo] = -127;		//close the claw
}


task main ()
{
	init();
	while(true) // infinite loop, to keep the program alive
	{
		//slowModeCheck();
		rotateBody();
		armVertical();
		extendArm();
		rotateClaw();
		toggleClaw();
	}
}